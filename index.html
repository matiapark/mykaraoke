<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>나의 노래방</title>
    <script src="https://unpkg.com/nosleep.js@0.12.0/dist/NoSleep.min.js"></script>
    <script src="https://unpkg.com/ml5@0.6.1/dist/ml5.min.js"></script>
    <style>
        /* CSS 스타일은 이전과 동일하게 유지됩니다 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            text-align: center;
            background: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            padding: 20px;
            overflow-y: auto;
            touch-action: manipulation;
        }
        h2 { margin-top: 0; }
        #search-view {
            max-width: 700px;
            margin: 40px auto;
            padding: 35px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-radius: 20px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .title-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
        }
        .title-wrapper h2 {
            font-size: 2.8em;
            font-weight: 700;
            color: #ffffff;
            margin: 0 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3), 0 0 20px rgba(255, 193, 7, 0.5);
        }
        .search-box {
            display: flex;
            margin-bottom: 20px;
            border-radius: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        #search-input {
            flex-grow: 1;
            padding: 10px 25px;
            font-size: 16px;
            border: none;
            outline: none;
            color: #333;
            background: #f0f0f0;
        }
        #search-button {
            padding: 10px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            background: #ffc107;
            color: #212529;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .view-toggle-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 20px;
        }
        .view-toggle-buttons button {
            flex-grow: 1;
            padding: 10px;
            font-size: 14px;
            font-weight: bold;
            color: #f0f0f0;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .view-toggle-buttons button.active {
            background-color: #ffc107;
            color: #212529;
            border-color: #ffc107;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }
        #search-results {
            list-style: none; padding: 0; margin: 0;
            max-height: calc(100vh - 510px); overflow-y: auto;
        }
        .result-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 20px; cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left; transition: background-color 0.3s ease;
        }
        .result-item:hover {
            background: linear-gradient(90deg, rgba(255, 193, 7, 0.2), rgba(255, 193, 7, 0));
        }
        .result-item .title { font-size: 1.1em; font-weight: bold; margin-bottom: 4px; color: #ffffff; }
        .result-item .artist { font-size: 0.9em; color: #bdc3c7; }
        .list-buttons { display: flex; gap: 10px; }
        .favorite-btn, .playlist-add-btn, .playlist-remove-btn {
            font-size: 24px; cursor: pointer; padding: 5px;
            transition: transform 0.2s ease, color 0.2s ease; color: #fff;
        }
        .favorite-btn.favorited { color: #ffc107; }
        .playlist-add-btn.added { color: #28a745; }
        #playerContainer { position: relative; width: 100%; padding-bottom: 56.25%; height: 0; overflow: hidden; background: #000; border-radius: 12px; box-shadow: 0 8px 25px rgba(0,0,0,0.5); margin: 15px 0; }
        #ytplayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        button { padding: 12px 25px; font-size: 18px; font-weight: bold; margin: 5px; cursor: pointer; border-radius: 25px; border: none; color: white; transition: all 0.2s ease-in-out; }
        #startBtn { background-color: #1DB954; }
        #startBtn:disabled { background-color: #555; cursor: not-allowed; }
        #stopBtn { background-color: #F44336; }
        #backBtn { background-color: #adb5bd; color: #212529; }
        #resultArea { margin-top: 20px; }
        #downloadBtn { background-color: #007bff; margin-left: 10px; }
    </style>
</head>
<body>
    <div id="search-view">
      <header>
          <div class="title-wrapper"><h2>🎤 나의 노래방</h2></div>
          <div class="search-box">
              <input type="text" id="search-input" placeholder="가수 이름 또는 노래 제목 입력...">
              <button id="search-button">검색</button>
          </div>
      </header>
      <div class="view-toggle-buttons">
          <button id="show-search-btn" class="active">전체 검색</button>
          <button id="show-favorites-btn">⭐ 즐겨찾기</button>
          <button id="show-recents-btn">🕓 최근 부른 곡</button>
          <button id="show-playlist-btn">🎶 연속 부르기</button>
      </div>
      <div id="search-results-container"><ul id="search-results"></ul></div>
      <div id="load-more-container" style="text-align: center; margin-top: 20px;">
          <button id="loadMoreBtn" style="display: none;">더 보기</button>
      </div>
    </div>
    <div id="karaoke-view" style="display: none;">
      <div id="karaoke-container">
        <header><h2 id="karaoke-title"></h2></header>
        <div id="playerContainer"><div id="ytplayer"></div></div>
        <footer>
          <div>
            <button id="startBtn" disabled>▶ 시작</button>
            <button id="stopBtn" disabled>⏹ 중단</button>
            <button id="backBtn">🔍 선곡</button>
          </div>
          <div id="resultArea" style="display:none;">
            <h4>녹음 완료!</h4>
            <audio id="recordedAudio" controls style="width: 100%;"></audio>
            <button id="downloadBtn" style="display: none;">💾 다운로드</button>
          </div>
        </footer>
      </div>
    </div>
    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // --- 전역 변수 ---
        let pitch, mediaRecorder, player, audioContext;
        let micSourceNode, micGainNode; // ## ALGORITHM: 가상 믹서(Gain) 노드 추가
        let recordedChunks = [], currentSongData = null;
        let isSinging = false, isPreparing = false, isStoppingManually = false;
        // (UI 관련 변수들은 생략)

        window.onload = () => {
            // UI 요소 할당 및 이벤트 리스너 설정 (생략)
        };
        
        function onYouTubeIframeAPIReady() { /* 생략 */ }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED && isSinging) {
                stopSinging();
            }
            if (event.data === YT.PlayerState.PAUSED && isSinging && !isStoppingManually) {
                player.playVideo();
            }
        }

        async function prepareKaraoke(songData) {
            isPreparing = true;
            currentSongData = songData;
            // UI 전환 (생략)
            await cleanupAudioResources();
            resetState();
            player.cueVideoById(songData.videoId);
            startBtn.disabled = false;
            stopBtn.disabled = true;
            isPreparing = false;
        }

        async function startSinging() {
            if (isPreparing || isSinging) return;
            isSinging = true;
            isStoppingManually = false;

            try {
                // ## ALGORITHM: 오디오 파이프라인 재설계 ##
                // 1. 원본 마이크 스트림 가져오기
                const rawMicStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
                
                // 2. 오디오 컨텍스트 및 가상 믹서(GainNode) 생성
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                micSourceNode = audioContext.createMediaStreamSource(rawMicStream);
                micGainNode = audioContext.createGain();
                micGainNode.gain.value = 1; // 기본 볼륨은 1(최대)

                // 3. 녹음기와 음정 분석기로 보낼 새로운 '처리된' 스트림 생성
                const destinationNode = audioContext.createMediaStreamDestination();
                micSourceNode.connect(micGainNode);
                micGainNode.connect(destinationNode);
                const processedStream = destinationNode.stream;

                // 4. 녹음기와 음정 분석기를 '처리된' 스트림으로 초기화
                mediaRecorder = new MediaRecorder(processedStream);
                setupMediaRecorder(currentSongData);

                pitch = await new Promise((resolve, reject) => {
                    ml5.pitchDetection('https://cdn.jsdelivr.net/gh/ml5js/ml5-data-and-models/models/pitch-detection/crepe/', audioContext, processedStream, (err, model) => {
                        err ? reject(err) : resolve(model);
                    });
                });

                // 5. 모든 컴포넌트 시작
                player.playVideo();
                mediaRecorder.start();
                getPitch();

                startBtn.disabled = true;
                stopBtn.disabled = false;
            } catch (err) {
                console.error("오디오 시작 실패:", err);
                isSinging = false;
            }
        }

        /** '중단' 버튼: 노래와 모든 관련 리소스를 '부드럽게' 중지합니다. */
        function stopSinging() {
            if (!isSinging) return;
            isStoppingManually = true;
            isSinging = false;
            
            startBtn.disabled = true;
            stopBtn.disabled = true;

            // ## ALGORITHM: 페이드 아웃 로직 ##
            if (micGainNode && audioContext && audioContext.state === 'running') {
                // 1. 볼륨을 0.1초에 걸쳐 0으로 줄임 (페이드 아웃)
                micGainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);

                // 2. 페이드 아웃이 끝난 후, 미디어를 정지시킴
                setTimeout(() => {
                    if (player) player.stopVideo();
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop(); // .onstop 이벤트에서 최종 cleanup이 실행됨
                    }
                }, 150);
            } else {
                // 오디오 컨텍스트가 없는 경우, 바로 정리
                if (player) player.stopVideo();
                cleanupAudioResources().then(() => {
                    startBtn.disabled = false;
                });
            }
        }

        function returnToSearchView() {
            if (isSinging) stopSinging();
            else cleanupAudioResources();
            // UI 전환 (생략)
        }

        /** MediaRecorder 설정 및 이벤트 핸들러 */
        function setupMediaRecorder(songForRecording) {
            mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };
            
            // 녹음이 완전히 멈췄을 때 실행되는 이벤트
            mediaRecorder.onstop = () => {
                if (!isStoppingManually) {
                    // UI 업데이트 및 파일 생성 (생략)
                }
                // 모든 작업이 끝난 후 최종적으로 오디오 리소스 정리
                cleanupAudioResources().then(() => {
                    if(startBtn) startBtn.disabled = false;
                });
            };
        }

        /** 모든 오디오 관련 리소스를 안전하게 해제 (가장 마지막에 호출) */
        async function cleanupAudioResources() {
            // 원본 마이크 스트림의 트랙을 중지
            if (micSourceNode && micSourceNode.mediaStream) {
                micSourceNode.mediaStream.getTracks().forEach(track => track.stop());
            }

            if (audioContext && audioContext.state !== 'closed') {
                await audioContext.close();
            }
            
            micSourceNode = null;
            micGainNode = null;
            audioContext = null;
            pitch = null;
            mediaRecorder = null;
            recordedChunks = [];
        }

        function getPitch() { /* 생략 */ }
        function resetState() { /* 생략 */ }
        
        // 나머지 UI 및 데이터 관리 함수들 (생략)

    </script>
</body>
</html>